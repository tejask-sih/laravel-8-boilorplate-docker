############################
## DO NOT EDIT THIS FILE! ##
############################
# If you'd like to add project-specific make recipies â€“ use Makefile.project.

#
# Variables and config import
#

include make.env
export $(shell sed 's/=.*//' make.env)

# Import project-specific make recipies
include Makefile.project

# Recipe defaults to help
.PHONY: help
.DEFAULT_GOAL := help

# Uppercase vars for internal use.
INTERACTIVE := $(shell [ -t 0 ] && echo 1)
UC = $(shell echo '$1' | tr '[:lower:]' '[:upper:]')
LOG_ERROR = @printf "\n>> \e[0;31m$1\e[0;00m\n\n"
LOG_WARN = @printf "\n>> \e[0;33m$1\e[0;00m\n\n"
LOG_INFO = @printf "\n>> \e[0;34m$1\e[0;00m\n\n"
LOG_SUCCESS = @printf "\n>> \e[0;36m$1\e[0;00m\n\n"
LOG_SUBLINE = @printf "   \e[0;34m$1\e[0;00m\n\n"

ifeq (${INTERACTIVE},1)
PROMPT = @printf "$1 [y/N] " && read ans && [ $${ans:-N} = y ]
else
PROMPT = @true
endif

# Lowercase vars for dynamic arguments.
docker_image = $(shell test -z ${DOCKER_REGISTRY} || echo ${DOCKER_REGISTRY}/)${PROJECT_NAMESPACE}/${PROJECT_NAME}
mode ?= $(shell cat .make 2>/dev/null || echo ${DEFAULT_MODE})
compose ?= -f docker-compose.yml

#
# Make tools
#

help:
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

init: ## Initialize Make mode `make init (mode=...)`, available modes: [local|sandbox|run]
	@echo ${mode} > .make
	$(call LOG_INFO,Make initialized in ${mode} mode)

terminate: ## Terminate Make mode
	@rm .make 2>/dev/null || exit 0
	$(call LOG_WARN,Make mode terminated)

#
# Show current info
#

showmode: ## Show current Make mode
	@echo ${mode}

### > make showgitver ###
GITSHA = $(shell git rev-parse HEAD)
GITVER = $(shell git describe --tags 2>/dev/null || echo ${GITSHA} | cut -b1-8 || echo "unknown")
showgitver: ## Show project verion
	@echo ${GITVER}
### < make showgitver ###

showcompose: ## Show currently used compose stack
	@echo ${compose}

#
# Docker
#

build: ## Docker: build & tag
	$(call LOG_INFO,Building fresh Docker image)
	docker-compose ${compose} build --pull ${ps}

up: ## Docker: start compose stack
	$(call LOG_INFO,Up (daemonized); showing logs (to close press Ctrl+C))
	docker-compose ${compose} up -d ${ps}
# ifeq (${INTERACTIVE},1)
# 	docker-compose ${compose} logs --tail 100 -f
# endif

down: ## Docker: destroy compose stack
	$(call PROMPT,This will wipe your current stack. Are you sure?)
	$(call LOG_INFO,Destroying Docker stack)
	docker-compose ${compose} down -v
	$(call LOG_WARN,Docker for project has been wiped out)

start: ## Docker: start containers
	$(call LOG_INFO,Starting (daemonized))
	docker-compose ${compose} start ${ps}

restart: ## Docker: restart containers
	$(call LOG_INFO,Restarting Docker containers)
	docker-compose ${compose} restart ${ps}

stop: ## Docker: stop containers
	$(call LOG_INFO,Stopping Docker containers)
	docker-compose ${compose} stop ${ps}

logs: ## Docker: show container's logs
	-docker-compose ${compose} logs --tail 100 -f ${ps}

ps: ## Docker: show containers
	docker-compose ${compose} ps

top: ## Docker: show container's processes
	docker-compose ${compose} top ${ps}

### > make shell ###
CMD_SHELL := "docker-compose ${compose} exec"
ifdef ps
	CMD_SHELL += "${ps}"
else
	CMD_SHELL += "${SERVICE_NAME}"
endif
ifdef cmd
	CMD_SHELL += "${cmd}"
else
	CMD_SHELL += "${DEFAULT_SHELL}"
endif
shell: ## Docker: enter container's shell, use `make shell (ps=...) (cmd="...")`
	@echo ${CMD_SHELL}
	@eval ${CMD_SHELL}
### < make shell ###

debug: ## Docker: run service's default shell without entrypoint
	$(call LOG_INFO,Debug shell mode with disabled entrypoint)
	docker-compose ${compose} run --entrypoint= ${SERVICE_NAME} ${DEFAULT_SHELL}

up-once: ## Docker: start compose stack, wait for main service to exit and exit if service exits
	$(call LOG_INFO,Starting Docker stack with main service awaiting to exit)
	docker-compose ${compose} up --force-recreate -V --abort-on-container-exit --exit-code-from ${SERVICE_NAME}

### > make run-once ###
SERVICE_TO_RUN := "${SERVICE_NAME}"
ifdef ps
	SERVICE_TO_RUN = ${ps}
endif
run-once: ## Docker: run a `cmd="..."` command in `ps=...` service (defaults to main service)
ifeq (${cmd},)
	$(call LOG_ERROR,You must enter command to run with cmd="..."!)
	@exit 255
endif
	$(call LOG_INFO,Running command: ${cmd})
	docker-compose ${compose} run --entrypoint=${entrypoint} --rm ${SERVICE_TO_RUN} ${cmd}
### < make run-once ###

#
# Registry
#

### > make ecr-login ###
CMD_ECRLOGIN := "eval $$\(aws ecr"
ifdef AWSCLI_PROFILE
CMD_ECRLOGIN += "--profile ${AWSCLI_PROFILE}"
endif
ifdef AWS_REGION
CMD_ECRLOGIN += "--region ${AWS_REGION}"
endif
CMD_ECRLOGIN += "get-login --no-include-email\)"
ecr-login: ## Docker login: to ECR registry with AWSCLI_PROFILE or AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
ifeq (${AWSCLI_PROFILE}${AWS_ACCESS_KEY_ID},)
	$(call LOG_ERROR,Either no AWSCLI_PROFILE nor AWS_ credentials specified!)
	@exit 255
endif
	$(call LOG_INFO,Logging to ECR registry)
	@echo ${CMD_ECRLOGIN}
	@eval ${CMD_ECRLOGIN}
### < make ecr-login ###

docker-login: ## Docker login: to DOCKER_REGISTRY
	$(call LOG_INFO,Logging to Docker registry)
	docker login ${DOCKER_REGISTRY}

#
# Standalone release management
#

ver ?= latest
from ?=
as ?=
dockerfile ?= Dockerfile
opts ?= --compress

docker-build:
	$(call LOG_INFO,Bulding source as :${ver})
	docker build ${opts} --pull -f ${dockerfile} -t ${docker_image}:${ver} .

docker-push:
ifneq (${from},)
	$(call LOG_INFO,Tagging current :${from} as :${ver})
	docker tag ${docker_image}:${from} ${docker_image}:${ver}
endif
	$(call LOG_INFO,Pushing current :${ver})
	docker push ${docker_image}:${ver}

docker-pull:
	$(call LOG_INFO,Pulling :${ver} from registry)
	docker pull ${docker_image}:${ver}
ifneq (${as},)
	$(call LOG_INFO,Tagging :${ver} as :${as})
	docker tag ${docker_image}:${ver} ${docker_image}:${as}
endif

#
# Deployment
#

service-deploy: ## Deployment: deploy/update service stack, use `make service-deploy stack=...`
ifeq (${stack},)
	$(call LOG_ERROR,You must enter stack name with stack=...!)
	@exit 255
endif
	docker stack deploy --with-registry-auth $(subst -f ,-c ,${compose}) ${stack}

service-rm: ## Deployment: remove deployed service stack, use `make service-rm stack=...`
ifeq (${stack},)
	$(call LOG_ERROR,You must enter stack name with stack=...!)
	@exit 255
endif
	docker stack rm ${stack}

### > make service-update ###
ver ?= latest
service-update: ## Deployment: update deployed service, use `make service-update stack=... ver=...`, ver defaults to `latest`
ifeq (${stack},)
	$(call LOG_ERROR,You must enter stack name with stack=...!)
	@exit 255
endif
ifeq (${ver},)
	$(call LOG_ERROR,You must enter version with ver=...!)
	$(call LOG_SUBLINE,You can use make showgitver and CI_ vars as ver=...)
	@exit 255
endif
	$(call LOG_INFO,Using ${stack} stack)
	$(call LOG_INFO,Updating ${stack}_${SERVICE_NAME} to ${docker_image}:${ver})
	docker service update --force --with-registry-auth "${stack}_${SERVICE_NAME}" --image ${docker_image}:${ver}
### < make service-update ###

#
# Standalone runs
#

local: ## Run: run in development mode
	$(call LOG_INFO,Using ${mode} for build up app)
	cp -rf env/local/. ./
	make down
	make init mode=local
	make build
	make up
	./composer install
	./php-artisan key:generate
	./php-artisan jwt:secret
	make logs

run: ## Run: run in production mode
	cp -rf env/prod/. ./
	make down
	make init mode=run
	make build
	make up

sandbox: ## Run : run in sandbox mode 
	cp -rf env/sandbox/. ./
	make down
	make init mode=sandbox
	make build
	make up
	make logs
